Embedded systems development with Go
14 Mar 2017
Tags: embedded systems, raspberry pi

John Schaeffer
john@schaeffer.io
http://schaeffer.io/

* What this talk will cover

- What embedded systems are
- Deploying code to the Raspberry Pi
- Interacting with GPIO (general purpose I/O) on supported devices
- Communicating with external hardware
- Writing high-level code to drive embedded systems

* What this talk will not cover

- How to write embedded systems code
- Running Go on bare metal (Go programs need to run on an OS)
- Electronics fundamentals (voltage, current, resistance, etc.)

* Overview

* What are embedded systems?

From Wikipedia: An embedded system is a computer system with a dedicated function within a larger mechanical or electrical system, often with real-time computing constraints.

.image ./img/smsc-ethernet-chip.jpg
.caption An SMSC ethernet chip on an embedded system. [[https://en.wikipedia.org/wiki/File:SMSC_LAN91C110_ethernet_chip.jpg][(source)]]

[[https://en.wikipedia.org/wiki/Embedded_system]]

* Why use Go for working with embedded systems?

- Usual advantages: compiled binaries, static typing, good performance
- Go build tools make cross-compilation for single-board devices easy
- Standard library support for (some) low-level I/O
- Good third-party support for GPIO operations

* Things you can do with Go and embedded systems

- Drive external devices using GPIO
- Communicate with external hardware, not just other computers
- Hook embedded systems into higher-level Go programs (who needs a Nest when you can build your own home thermostat?)

* Things you can't do with Go and embedded systems

- Run code on an embedded device

This is a small but important point: embedded software runs on bare metal, directly manipulating registers and memory. Go programs run on top of an operating system and rely on the capabilities of an OS to function.

* Go and the Raspberry Pi

* Overview of the Raspberry Pi 3

- Low-cost ($35 USD) single-board computer
- 1.2 GHz ARM processor, 1GB RAM, 4 USB ports, HDMI output
- GPIO, 3.3V pin headers
- microSD card mount for OS, storage

.image ./img/raspberry-pi-3.jpg
.caption A Raspberry Pi 3 model B.

Source: [[https://en.wikipedia.org/wiki/Raspberry_Pi]]

* Developing for the Raspberry Pi

- Go tools put intermediate files in `/tmp` during build
- SD cards are slow and burn out easily
- Therefore, we either want to mount `/tmp` outside of the card or build our Go binaries elsewhere
- We'll be taking the second option for this talk

Note: These instructions are Linux-specific. Raspbian ([[http://raspbian.org]]) is a popular Debian-based Linux distribution for the Pi.

* Cross-compiling Go programs

- Bootstrapping compiler means Go can build itself for any available target
- Use `GOOS` and `GOARCH` environment variables to control build target
- For ARM devices, set `GOARM` environment variable for appropriate ARM version

  $ GOOS=linux GOARCH=arm GOARM=7 go build github.com/my/project/cmd/foo

- Deploy using whatever method you prefer (`scp`, FTP, network filesystem, etc.)

Note: Raspberry Pi 3 has ARMv8 processor, but 32-bit OSes will report it as ARMv7

* Things to keep in mind

- Binaries built with `cgo` are not statically linked
- Go programs with C dependencies will probably break
- To disable `cgo`, set the environment variable `CGO_ENABLED` to `0`

  $ CGO_ENABLED=0 GOOS=linux GOARCH=arm GOARM=7 go build ...

* Working with GPIO

* Overview of GPIO

- GPIO (general-purpose input/output) is a class of pins on an integrated circuit that have no predefined function
- Fully programmable, great for interacting with external devices and sensors
- Allows us to write programs at the application layer that work with physical hardware

* Manipulating GPIO using Go

- Multiple options exist for doing GPIO in Go
- RPi specific: `github.com/stianeikeland/go-rpio`
- Generic (Beaglebone, RPi, etc.): `github.com/kidoman/embd` and `github.com/mrmorphic/hwio`
- Using `go-rpio` here

* Example: Toggling LEDs

- Components: External power supply, LEDs, resistors, transistors

* Things to keep in mind

- Application-level GPIO can't capture interrupts (Linux doesn't support it)
- GPIO pins are not designed to supply power! Doing so can fry your device
- Generic GPIO packages might not map pins the way you expect - check the source

* Communicating with other devices

* SPI overview

* Communicating over SPI using Go

* Example: MSP430 ADC readings

* Things to keep in mind

* Bringing it all together

* What we've covered

* Things to remember

* Project ideas
